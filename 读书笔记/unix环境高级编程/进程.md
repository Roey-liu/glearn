# 进程环境

## 1.进程的启动与终止

<div align="center"> <img src="pic/apue-processenv-3.png"/> </div>

### 1.1 main函数

当内核通过`exec`函数执行 C 程序、在调用`main`之前先调用一个特殊的启动例程

* 可执行程序文件将此启动例程指定为程序的起始地址（这是由链接器设置的，而链接器由C编译器调用）
* 启动例程从内核取得命令行参数和环境变量值，为调用`main`函数做好安排

启动例程使得从main返回后立即调用exit函数。

```c
exit(main(argc,argv));
```

### 1.2 进程终止的方式

有 8 种方式使得进程终止，其中 5 种为正常终止，3 种异常终止：


- **正常终止方式**：
    - 从`main`函数返回
    - 调用`exit`函数
    - 调用`_exit`函数或者`_Exit`函数
    - 多线程的程序中，最后一个线程从其启动例程返回
    - 多线程的程序中，从最后一个线程调用`pthread_exit`函数
- **异常终止方式**：
    - 调用`abort`函数
    - 接收到一个信号
    - 多线程的程序中，最后一个线程对取消请求作出响应

### 1.3 终止函数

三个终止函数的区别：
- `_exit`和`_Exit`函数：立即进入内核
- `exit`函数：先执行一些清理处理，然后进入内核

### 1.4 终止状态

`exit`、`exit`、`_Exit` 都带有一个整型参数，称为终止状态（或称作退出状态）。


* 下列情况，进程的**终止状态是未定义**的：
    + 若调用`exit`、`exit`、`_Exit`时不带终止状态
    + 若`main`执行了一个无返回值的`return`语句
    + 若`main`没有声明返回类型为整型
* 下列情况，进程的**终止状态是0**： 
    + 若`main`声明返回类型为整型，并且`main`执行到最后一条语句时返回（隐式返回）


### 1.5 登记终止处理程序
```
#include <stdlib.h>
int atexit(void (*function)(void));
```
按照ISO C的规定，一个进程可以登记最多32个函数（通常操作系统会提供多于32个的限制。可以用`sysconf`函数查询这个限制值），这些函数将由`exit`函数自动调用。这些函数称作**终止处理程序**

* `exit`调用这些终止处理程序的顺序与它们登记的时候顺序相反
* 如果同一个终止处理程序被登记多次，则它也会被调用多次


## 2.环境表

每个程序都会接收一张**环境表**
- 与参数表一样，环境表也是一个字符指针数组
    - 其中数组中的每个指针指向一个以`null`结束的 C 字符串，这些字符串称之为环境字符串
    - 数组的最后一项是`null`
- 全局变量`environ`包含了该指针数组的地址：`extern char **environ`。我们称`environ`为环境指针，它位于头文件`unistd.h`中
- 按照惯例，环境字符串由`name=value`这种格式的字符串组成

<div align="center"> <img src="pic/apue-processenv-4.png"/> </div>

> 环境表和环境字符串通常存放在进程存储空间的顶部（栈的上方）


## 3.C程序的存储空间布局


* **正文段**（.text段）：这是由CPU执行的机器指令部分
    * 通常正文段是可以共享的。一个程序可以同时执行`N`次，但是该程序的正文段在内存中只需要有一份而不是`N`份
    * 通常正文段是只读的，以防止程序由于意外而修改其指令
* **初始化数据段**（.data段）：通常将它称作数据段（存放在磁盘可执行文件中，故而占磁盘空间）
    * 它包含了程序中明确地赋了初值的变量：包括**函数外的赋初值的全局变量**、**函数内的赋初值的静态变量**
* **未初始化数据段**（.bss段）：通常将它称作**bss段**。在程序开始执行之前，内核将此段中的数据初始化为0或者空指针
    * 它包含了程序中未赋初值的变量：包括**函数外的未赋初值的全局变量**、**函数内的未赋初值的静态变量**
* **栈**：临时变量以及每次函数调用时所需要保存的信息都存放在此段中
    * 每次函数调用时，函数返回地址以及调用者的环境信息（如某些CPU 寄存器的值）都存放在栈中
    * 最新的正被执行的函数，在栈上为其临时变量分配存储空间（通过这种方式使用栈，C 递归函数可以工作。递归函数每次调用自身时，就创建一个新的栈帧，因此某一次函数调用中的变量不影响下一次调用中的变量）
* **堆**：通常在堆中进行动态存储分配
    * 由于历史习惯，堆位于未初始化数据段和栈段之间

## 4.共享库

### 静态链接库与动态链接库

* **静态链接库**
    - 扩展名为`.a`，通常命名为`libxxx.a`
    - 整合到可执行文件中，因此会导致可执行文件体积增大
    - 可独立执行，而不需要再向外部要求读取链接库的内容
    - 链接库升级时，需要重新编译生成可执行文件

* **动态链接库**
    - 扩展名为`.so`，通常命名为`libxxx.so`
    - 动态链接库的内容并没有整合到可执行文件中，需要使用时才去读取链接库，因此可执行文件体积较小
    - 不能独立执行，链接库必须存在
    - 链接库升级时，通常不需要重新编译

为了加速动态链接库的访问效率，一般需要将动态链接库载入内存中，从而避免读取磁盘。加载到高速缓存中的动态链接库所在的目录在文件`/etc/ld.so.conf`中指定，可以使用命令`ldconfig`将该文件中指定目录下的动态库读入缓存中

如果在编译时指定了动态链接库及库的路径，但是`/etc/ld.so.conf`文件中没有包含该路径，即这个动态链接库没有载入内存，那么运行生成的可执行文件会报错

`ldd`命令可以查看某个可执行的二进制文件含有什么动态链接库，对于前面的问题，如果某个动态链接库没有载入内存，即动态链接库的路径没有包含在文件`/etc/ld.so.conf`中。使用ldd查看时，这个库会显示“not found”

## 5.进程堆空间的管理




# 五.进程控制
