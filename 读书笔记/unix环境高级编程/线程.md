# 1.线程

**线程之间的资源共享**：

* **同一进程内的线程共享**
    - 相同的全局内存
    - 进程指令
    - 大多数数据
    - 打开的文件（即描述符）
    - 信号处理函数和信号设置
    - 当前工作目录
    - 用户ID和组ID
* **线程之间不共享**
    - 线程ID
    - 寄存器集合（包括程序计数器和栈指针）
    - 栈（用于存放局部变量和返回地址）
    - errno
    - 信号掩码
    - 优先级


## 1.相关函数

### 1）pthread_create函数
```c++
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
	void *(*start_routine) (void *), void *arg);
```


**如果发生错误，函数返回指示错误的某个正值，不会设置errno变量**

**创建的线程通过调用指定的函数开始执行，然后显示地（通过调用pthread_exit）或隐式地（通过让该函数返回）终止**

**线程创建时，并不能保证哪个线程会先运行**


### 2）pthread_join函数
```c
int pthread_join(pthread_t thread, void **retval);
```
pthread_join类似于进程中的waitpid，用于等待一个给定线程的终止  

对于一个非脱离状态的线程，如果没有其它线程调用pthread_join等待线程终止，那么线程终止后的资源无法回收，会造成资源浪费，进而影响同一进程创建的线程数量


### 3）pthread_self函数

线程可以使用pthread_self获取自身的线程ID，类似于进程中的getpid

### 4）pthread_detach函数
该函数把指定的线程转变为**脱离状态**，通常由想让自己脱离的线程```pthread_detach(pthread_self());```

一个线程或者是**可汇合**的，或者是**脱离**的：


* **可汇合**：一个可汇合线程终止时，它的线程ID和退出状态将保存到另一个线程对它调用pthread_join。如果一个线程需要知道另一个线程什么时候终止，那就最好保持第二个线程的可汇合状态
* **脱离**：脱离的线程像守护进程，当它们终止时，所有相关资源都被释放，不能等待它们终止
    - 一般在不关心线程返回状态，希望系统在线程终止时自动清理并退出时调用`pthread_detach`
    - 其它线程调用了`exit`，或是主线程执行`return`时，即便是分离的线程也会终止。换而言之，**`pthread_detach`只是控制线程终止之后所发生的事情，而非何时或如何终止线程**


### 5）pthread_exit函数
线程终止的**一个方法**：


让一个线程终止的**其它**方法：

1. **线程执行的函数返回**，在`pthread_create`参数中，这个函数的返回值是一个void\*指针，它指向相应线程的终止状态
2. **被同一进程的其它线程调用`pthread_cancel`取消**（该函数只是发起一个请求，目标线程可以选择忽略取消或控制如何被取消）
3. **任何线程调用`return` `exit`、`_Exit`、`_exit`终止时，整个进程就终止了，其中包括它的任何线程**

> 如果主线程调用了`pthread_exit`，而非`exit`或`return`，那么其它线程将继续运行

### 6）pthread_equal函数
比较线程ID，线程ID的大小没有意义。 

引入原因：
* 在线程中，线程ID的类型是pthread_t类型，由于在Linux下线程采用POSIX标准，所以，在不同的系统下，pthread_t的类型是不同的，比如在ubuntn下，是unsigned long类型，而在solaris系统中，是unsigned int类型。而在FreeBSD上才用的是结构题指针。 所以不能直接使用==判读，而应该使用pthread_equal来判断。

### 7）pthread_cancel函数
该函数可以被某一线程调用，用来请求取消同一进程中的其它线程

* 函数只是发起取消请求，目标线程可以忽略取消请求或控制如何被取消（即执行一些清理函数）

### 8）pthread_cleanup_push和pthread_cleanup_pop函数
```c
void pthread_cleanup_push(void (*rtn)(void *), void *arg);
void pthread_clean_pop(int execute);
```


**下列情况会调用清理函数**：

* 线程调用`pthread_exit`时
* 线程响应取消请求时
* 用非零`execute`参数调用`pthread_cleanup_pop`时

**以下情况不会调用清理函数**；

* 线程通过`return`或`exit`终止时
* `execute`参数为0时

不管`excute`参数是否为0，`pthread_cleanup_pop`函数都会将线程清理函数栈的栈顶函数删除


## 2.线程同步

* 1）**互斥锁**
* 2）**读写锁**
* 3）**条件变量**
* 4）**自旋锁**
* 5）**屏障**

### 2.1 互斥锁

如果释放互斥锁时，有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥锁加锁，其它线程就会看到互斥锁依然是锁着的，只能回去再次等待它重新变为可用。这种方式下，每次只有一个线程可以向前执行

**使用互斥锁时避免死锁**：

* 如果线程试图对一个互斥锁加锁两次，那么它自身就会陷入死锁状态
* 如果使用多个互斥锁，并且每个线程取得其中一个，阻塞于对另一个的请求上，也会死锁
    - 1）可以通过控制加锁的顺序来防止
    - 2）如果尝试获取另一个锁时失败，那么释放自己占有的锁，过一段时间再试

### 2.2 读写锁
> 也称作**共享互斥锁**：当读写锁是读模式锁住时，可以说成是共享模式锁住的；当它是写模式锁住时，可以说成是以互斥模式锁住的

**读写锁非常适合于对数据结构读的次数远大于写的情况**

### 2.3 条件变量

条件变量可以在某个条件发生之前，将线程投入睡眠


* **pthread_cond_wait**函数等待`cond`指向的条件变量，投入睡眠之前会释放`mutex`指向的互斥锁，唤醒后会重新获得`mutex`指向的互斥锁
* **pthread_cond_signal**：至少能唤醒一个等待该条件的线程
* **pthread_cond_broadcast**：能唤醒所有等待该条件的线程

### 2.4 自旋锁
自旋锁与互斥锁类似，区别是：自旋锁在获取锁之前一直处于忙等（自选）阻塞状态。因为忙等会消耗大量CPU，因此适用于锁持有时间不长（即操作可以较快完成）的场景

> 事实上，有些互斥锁的实现在试图获取互斥锁的时候会自旋一小段时间，只有在自旋计数到达某一阈值的时候才会休眠


### 2.5 屏障

**屏障是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行**


> `pthread_join`就是一种屏障，允许一个线程等待，直到另一个线程退出




# 2.线程控制



## 1.栈与堆是公有的还是私有的？

**在多线程环境下，每个线程拥有一个栈和一个程序计数器**栈和程序计数器用来保存线程的执行历史和线程的执行状态 其他的资源（比如堆、地址空间、全局变量）是由同一个进程内的多个线程共享。

## 2.线程属性

**线程属性用以初始化线程，定义在结构体`pthread_attr_t`中**，一般包括：

* 分离状态属性
* 线程栈末尾的警戒缓冲区大小
* 线程栈的最低地址
* 线程栈的最小长度(字节)



## 3.同步属性
就像线程具有属性一样，线程的同步对象也有属性。**在使用某种线程同步机制时，同步属性用以初始化相应的同步机制。比如互斥锁属性用以初始化互斥锁、条件变量属性用以初始化条件变量...**

## 4.线程特定数据


## 5.线程和信号

每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号，但当线程修改了与某个给定信号相关的处理行为以后，所有的线程都必须共享这个处理行为的改变。这样，如果一个线程选择忽略某个给定信号，那么另一个线程就可以通过以下两种方式撤销上述信号选择：恢复信号的默认处理行为，或者为信号设置一个新的信号处理程序

进程中的信号是递送到单个线程的：

* 如果一个信号与硬件故障相关，那么该信号一般会被发送到引起该事件的线程中去
* 其它的信号则被发送到任意一个线程

## 6.线程和fork

线程调用fork时，就为子进程创建了整个进程地址空间的副本：

* 子进程通过继承整个地址空间的副本，还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态
* 子进程内部只存在一个线程，它由父进程中调用fork的线程的副本构成。如果父进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，所以子进程没有办法知道它占有了哪些锁、需要释放哪些锁

如果fork后马上调用其中一个`exec`函数，就能避免这样的问题。这种情况下，旧的地址空间被丢弃，所以锁的状态无关紧要

在多线程的进程中，为了避免不一致状态的问题，POSIX.1声明，在fork返回和子进程调用其中一个`exec`之间，子进程只能调用**异步信号安全**的函数。这就限制了在调用`exec`之前子进程能做什么，但不涉及子进程中锁状态的问题

## 7.线程和I/O

在多线程进程中，因为线程共享相同的文件描述符，所以应该使用`pread`和`pwrite`而不是`read`和`write`，使得偏移量的设定和数据的读取成为一个原子操作