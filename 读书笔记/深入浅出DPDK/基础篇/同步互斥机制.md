## 原子操作

比较并交换
操作数（CAS， Compare And Set） 。

CAS操作需要输入两个数值， 一个旧值（期望操作前的值） 和一个
新值， 在操作期间先比较下旧值有没有发生变化， 如果没有发生变化，
才交换成新值， 发生了变化， 则不交换。

DPDK原子操作实现和应用


## 读写锁

DPDK读写锁的定义在rte_rwlock.h文件中，

rte_rwlock_init（rte_rwlock_t*rwl） ： 初始化读写锁到unlocked状
态。
rte_rwlock_read_lock（rte_rwlock_t*rwl） ： 尝试获取读锁直到锁被
占用。
rte_rwlock_read_unlock（rte_rwlock_t*rwl） ： 释放读锁。
rte_rwlock_write_lock（rte_rwlock_t*rwl） ： 获取写锁。
rte_rwlock_write_unlock（rte_rwlock_t*rwl） ： 释放写锁。

读写锁在DPDK中主要应用在下面几个地方， 对操作的对象进行保
护

在查找空闲的memory segment的时候， 使用读写锁来保护memseg
结构。 LPM表创建、 查找和释放。
·Memory ring的创建、 查找和释放。
·ACL表的创建、 查找和释放。
·Memzone的创建、 查找和释放等。

## 自旋锁

因为自旋锁不会引起调用者睡眠， 所以自旋锁的
效率远高于互斥锁。 虽然自旋锁的效率比互斥锁高， 但是它也有些不足
之处：

1） 自旋锁一直占用CPU，

2） 在用自旋锁时有可能造成死锁， 当递归调用时有可能造成死
锁， 

因此我们要慎重使用自旋锁， 

DPDK中自旋锁API的定义在rte_spinlock.h文件中

其中下面三个
API被广泛的应用在告警、 日志、 中断机制、 内存共享和link bonding的
代码中， 用于临界资源的保护。


## 无锁机制

在这种高并发的环境下， 锁竞争机制有时会比数据拷贝、 上下文
切换等更伤害系统的性能。 因此， 在多核环境下， 需要把重要的数据结
构从锁的保护下移到无锁环境， 以提高软件性能


如果
仅仅有一个读用户和一个写用户， 那么不需要添加互斥保护机制就可以
保证数据的正确性。 但是， 如果有多个读写用户访问环形缓冲区， 那么
必须添加互斥保护机制来确保多个用户互斥访问环形缓冲区。 具体来
讲， 如果有多个写用户和一个读用户， 那么只是需要给写用户加锁进行
保护； 反之， 如果有一个写用户和多个读用户， 那么只是需要对读用户
进行加锁保护


在Linux内核代码中， kfifo就是采用无锁环形缓冲的实现， kfifo是
一种“First In First Out”数据结构， 


### 环形缓冲区的剖析

这个环形结构是
由两个头和尾组成， 一组被生产者使用， 另一组被消费者使用。下面的
图分别用prod_head、 prod_tail、 cons_head和cons_tail来指代它们