
可能阻塞的**套接字调用**可分为以下4类：

* **输入操作**：包括read、readv、recv、recvfrom和recvmsg
    - **阻塞**：如果套接字的接收缓冲区中没有数据可读，进程将被投入睡眠
    - **非阻塞**：如果输入操作不能被满足，相应调用将立即返回一个EWOULDBLOCK错误
* **输出操作**：包括write、writev、send、sendto和sendmsg
    - **阻塞**：如果套接字的发送缓冲区中没有空间，进程将被投入睡眠
    - **非阻塞**：如果发送缓存区中根本没空间，返回一个EWOULDBLOCK错误；如果有一些空间，返回值是内核能够复制到该缓冲区中的字节数，也称为”不足计数“
* **发起连接**：用于TCP的connect
    - **阻塞**：connect将阻塞到3路握手的前2路完成（即至少阻塞1个RTT）
    - **非阻塞**：如果对于一个非阻塞的TCP套接字调用connect，并且连接不能立即建立，那么照样会发起连接，但会返回一个EINPROGRESS错误
* **接受连接**：accept
    - **阻塞**：如果尚无新的连接到达，调用进程将被投入睡眠
    - **非阻塞**：如果尚无新的连接到达，调用将立即返回一个EWOULDBLOCK错误

**通过将套接字描述符设置为非阻塞，从而使得相应的套接字调用为非阻塞**

**不仅限于套接字描述符，将任意文件描述符设置为非阻塞有2种方法**：

1. **如果调用`open`获得描述符，则可指定`O_NONBLOCK`标志**
2. **对于已经打开的一个描述符，可调用`fcntl`，由该函数打开`O_NONBLOCK`文件状态标志**

## 1.非阻塞读和写

使用select版的str_cli函数存在一个问题：如果套接字发送缓冲区已满，writen调用将会阻塞。在进程阻塞于writen调用期间，可能有来自套接字接收缓冲区的数据可供读取。类似的，如果从套接字中有一行输入文本可读，那么一旦标准输出比网络还慢，进程照样可能阻塞于后续的write调用



## 2.非阻塞connect

如果对于一个非阻塞的TCP套接字调用connect，并且连接不能立即建立，那么照样会发起连接，但会返回一个EINPROGRESS错误。接着使用select检查这个连接或成功或失败的已建立条件。非阻塞的connect有3个用途：

1. **可以把3路握手叠加在其他处理上**（完成一个connect要花一个RTT，而RTT波动范围很大，这段时间内也许有想要执行的其他处理工作可执行）
2. **同时建立多个连接**（这个用途已随web浏览器变得流行起来）
3. 既然使用select等待连接建立，**可以给select指定一个时间限制，缩短connect的超时**（许多实现有着75s到数分钟的connect超时时间）

使用非阻塞式connect时，必须处理下列细节：

* 尽管套接字非阻塞，如果连接到的服务器在同一个主机上，那么当我们调用connect时，连接通常立刻建立。因此，必须处理这种情况
* 源自Berkeley的实现对于select和非阻塞connect有以下两个规则：
    - **当连接成功建立时，描述符变为可写**
    - 当连接建立遇到错误时，描述符变为既可读又可写

**非阻塞connect是网络编程中最不易移植的部分（比如，一个移植性问题是如何判断连接成功建立）**

> **被中断的connect**：对于一个正常的阻塞式套接字，如果其上的connect调用在TCP三路握手完成前被中断（譬如捕获了某个信号）：如果connect调用不由内核自动重启，那么它将返回EINTR。不能再次调用connect等待未完成的连接继续完成，否则会返回EADDRINUSE错误。只能调用select像处理非阻塞式connect那样处理



## 3.非阻塞accept


* 当使用select获悉某个监听套接字上何时有已完成连接准备好被accept时，总是把这个监听套接字设置为非阻塞
* 在后续的accept调用中忽略以下错误：EWOULDBLOCK(源自Berkeley的实现，客户终止连接时)、ECONNABORTED(POSIX实现，客户终止连接时)、EPROTO(SVR4实现，客户终止连接时)和EINTR(如果有信号被捕获)