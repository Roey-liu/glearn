

# 一.文件I/O

## 1.文件描述符
对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负数。范围是0~OPEN_MAX-1。当进程创建时，默认为它打开了3个文件描述符，它们都链接向终端：

* 0：STDIN_FILEN   标准输入   
* 1：STDOUT_FILENO 标准输出
* 2：STDERR_FILENO 标准错误输出

这三个常量位于`<unistd.h>`中

复制文件描述符
```
 #include <unistd.h>
 int  dup(int fd);
 int  dup2(int fd, int fd2);
```

* 对于`dup`函数
    - 返回的新的文件描述符一定是当前可用的文件描述符中最小的数字
* 对于`dup2`函数：可以用fd2指定新描述符的值
    - 如果 `fd2`已经是被打开的文件描述符且不等于`fd`，则先将其关闭，然后再打开（<font color='red'>注意关闭再打开是一个原子操作</font>）
    - 如果 `fd2`等于`fd`，则直接返回`fd2`（也等于`fd`），而不作任何操作

这些函数返回的新文件描述符与参数fd共享同一个文件表项:

<div align="center"> <img src="pic/dup.png"/> </div>

<br>

## 2.相关调用



## 3.进程间文件共享

<div align="center"> <img src="pic/apue-fileio-14.png"/> </div>

UNIX系统支持在不同进程间共享打开文件。内核使用3种数据结构描述打开文件。它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响

* 内核为每个进程分配一个**进程表项**（所有进程表项构成进程表），进程表项中都有一个打开的文件描述符表。每个文件描述符占用一项，其内容为：
    * 文件描述符标志
    * 指向一个文件表项的指针
* 内核为每个打开的文件分配一个**文件表项**（所有的文件表项构成文件表）。每个文件表项的内容包括：
    * 文件状态标志（读、写、添写、同步和阻塞等）
    * 当前文件偏移量
    * 指向该文件 v 结点表项的指针
* 每个打开的文件或者设备都有一个 **v 结点结构**。 v 结点结构的内容包括： 
    * 文件类型和对此文件进行各种操作函数的指针
    * 对于大多数文件， v 结点还包含了该文件的 i 结点
    **这些信息都是在打开文件时从磁盘读入内存的**。

同一进程（程序），多次open同一个文件 （覆盖）
<div align="center"> <img src="pic/apue-fileio-7.png"/> </div>

多个进程（程序），共享操作同一个文件 （覆盖）
<div align="center"> <img src="pic/apue-fileio-8.png"/> </div>

```
覆盖的原因: 因为各自有独立的文件位移量。
```

## 4.原子操作

> 多个进程写同一文件时，可能产生预想不到的结果。为了避免这种情况，需要理解原子操作

UNIX提供了一种原子操作方法：通过 `O_APPEND`选项打开文件。这样做使得内核在每次调用 `write` 执行写操作之前，都将进程的当前偏移量设置到该文件的末尾，于是就不需要执行`lseek`定位操作

## 5.数据同步

以下2种情况会将缓冲区中的数据写回到磁盘：

- 当内核需要重用缓冲区来存放其他数据时，它会把所有延迟写的数据写入磁盘
- 可以调用`sync`、`fsync`或`fdatasync`来显式的将所有延迟写的数据块写回磁盘

3个函数的区别：

- `sync`（`update` 守护进程会周期性(一般每隔30s)的调用`sync`函数。命令`sync`也会调用`sync`函数）：
    + 将所有修改过的块缓冲区排入写队列，然后返回
    + 它并不等待实际写磁盘操作结束
- `fsync`：
    + 只对由`fd`指定的单个文件起作用
    + 等待写磁盘操作结束才返回
- `fdatasync`：
    + 只对由`fd`指定的单个文件起作用，但是它只影响文件的数据部分（`fsync`会同时更新文件的属性）
    + 等待写磁盘操作结束才返回


# 二.标准I/O库

## 1.流

###  3个标准流

- **标准输入**：预定义的文件指针(FILE对象)为`stdin`，它内部的文件描述符就是`STDIN_FILENO`
- **标准输出**：预定义的文件指针(FILE对象)为`stdout`，它内部的文件描述符就是`STDOUT_FILENO`
- **标准错误**：预定义的文件指针(FILE对象)为`stderr`，它内部的文件描述符就是`STDERR_FILENO`

## 2.FILE对象
当使用`fopen`函数打开一个流时，它返回一个指向`FILE`对象的指针（书中称作**文件指针**）。该对象通常是一个结构，包含了标准I/O库为管理该流所需要的所有信息，包括：

* 用于实际I/O的文件描述符
* 指向用于该流缓冲区的指针
* 该流缓冲区的长度
* 当前在缓冲区中的字符数
* 出错标志

## 3.缓冲

### 3.1 三种缓冲类型

标准I/O库提供了三种类型的缓冲：

- **全缓冲**：此时在标准I/O缓冲区被填满后，标准I/O库才进行实际的I/O操作
- **行缓冲**：此时当输入和输出中遇到换行符时，标准I/O库执行实际的I/O操作。
    - 只要填满了缓冲区，即使还没有写一个换行符，也立即进行I/O操作
    - 任何时候只要通过标准I/O库，从一个不带缓冲的流或者一个行缓冲的流得到输入数据，则会冲洗所有行缓冲输出流。(<font color='red'>即要缓冲输入，先冲洗输出缓冲</font>)
- **不带缓冲**：标准I/O库不进行缓冲。此时任何I/O都立即执行实际的I/O操作


### 3.2 缓冲区冲洗

* 缓冲区可以由标准的I/O操作自动地冲洗（如，当填满一个缓冲区时）
* 也可以手动调用fflush函数冲洗一个流

冲洗并不是立即写到磁盘文件中。冲洗只是负责数据传到内核

## 4.相关调用


# 三.高级I/O

下图为UNIX下5种I/O模型的比较

<div align="center"> <img src="pic/apue-advio-6.png"/> </div>


* **同步I/O**：I/O操作过程中会导致请求进程阻塞，直到I/O操作完成
    - **1）阻塞式I/O**：进程会在整个调用开始到结束一直阻塞
    - **2）非阻塞式I/O**：非阻塞指I/O调用不导致进程睡眠。如果描述符未就绪，返回一个错误，因为需要轮询直到描述符就绪，因此会耗费大量CPU
    - **3）I/O复用**：I/O复用的优势在于可以等待多个描述符就绪
    - **4）信号驱动I/O**：内核在描述符就绪时发送`SIGIO`信号进行通知。优势在于等待数据报到达期间进程不被阻塞。主循环可以继续执行
* **异步I/O**：不导致请求进程阻塞
    - **5）异步I/O**：这种模型与信号驱动模型的主要区别在：信号驱动I/O是由内核通知我们何时启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成

## 2 文件锁

**记录锁的功能是：当第一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区**

有两种类型的锁：**共享性读锁**(`l_type=F_RDLCK`)，**独占性写锁**(`l_type=F_WRLCK`)。

<div align="center"> <img src="pic/apue-advio-1.png"/> </div>

注意：该规则适用于不同进程提出的锁请求，不适合单个进程提出的多个锁请求。如果某个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一个文件区间再加一把锁，则新锁将会替换旧锁

实现原理

<div align="center"> <img src="pic/读写锁原理.png"/> </div>


其它值得注意的地方  
* （a）在同一进程中，如果多个文件描述符指向同一文件，只要关闭其中任何一个文件描述符  那么该进程加在文件上的所有文件锁将会被删除，也就是该进程在“文件锁链表”上的“读锁写锁”节点会被删除。进程终止时会关闭所有打开的文件描述符，所以进程结束时会自动删除所有加的文件锁。

* （b）父进程所加的文件锁，子进程不会继承