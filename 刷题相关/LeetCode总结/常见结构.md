# 基础数据结构

## 数组、字符串（Array & String）
### 数组的优缺点  
数组的优点在于：  
* 构建非常简单  
* 能在O(1)的时间里根据数组的下标（index）查询某个元素  

数组的缺点在于：

* 构建时必须分配一段连续的空间
* 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）
* 删除和添加某个元素时，同样需要耗费 O(n) 的时间

### 例题分析
```
LeetCode 第 242 题：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。

说明：你可以假设字符串只包含小写字母。

示例 1
输入: s = "anagram", t = "nagaram"
输出: true

示例 2
输入: s = "rat", t = "car"
输出: false
```
解题思路
```
可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0。
```
代码实现
```
bool isAnagram(string s, string t) {	
	if (s.size() != t.size()) {
		return false;
	}

	vector<int>alph(26,0);

	for (size_t i = 0; i < s.size(); i++){
		alph[s[i] - 'a']++;
		alph[t[i] - 'a']--;	
	}


	for (size_t i = 0; i < 26; i++)
	{
		if (alph[i] != 0) {
			return false;
		}
	}

	return true;
}
```
### 链表（LinkedList）
#### 链表的优缺点
链表的优点如下：
* 链表能灵活地分配内存空间；
* 能在 O(1) 时间内删除或者添加元素

链表的缺点是：
* 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；
* 查询第 k 个元素需要 O(k) 时间。

### 应用场景：  
如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。

### 经典解法

1-利用快慢指针（有时候需要用到三个指针）  

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等

2-构建一个虚假的链表头  
一般用在要返回新的链表的题目中  
比如，给定两个排好序的链表，要求将它们整合在一起并排好序。  
又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

### 例题分析
```
LeetCode 第 25 题：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：
给定这个链表：1->2->3->4->5
当 k=2 时，应当返回：2->1->4->3->5
当 k=3 时，应当返回：3->2->1->4->5
```
解题思路
```
借助三个指针：prev、curr、next

将 curr 指向的下一节点保存到 next 指针；
curr 指向 prev，一起前进一步；
重复之前步骤，直到 k 个元素翻转完毕；

当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。
```

## 栈 队列 双端队列
### 栈
#### 应用场景：
 在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。  

#### 例题分析一
```
LeetCode 第 20 题：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意：空字符串可被认为是有效字符串。

示例 1
输入: "()"
输出: true

示例 2
输入: "(]"
输出: false
```
解题思路
```
利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。
```
#### 例题分析二
```
LeetCode 第 739 题：根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

提示：气温列表 temperatures 长度的范围是 [1, 30000]。

示例：给定一个数组 T 代表了未来几天里每天的温度值，要求返回一个新的数组 D，D 中的每个元素表示需要经过多少天才能等来温度的升高。
给定 T：[23, 25, 21, 19, 22, 26, 23]
返回 D: [1, 4, 2, 1, 1, 0, 0]
```
解题思路
```
可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。
```
### 队列（Queue）
#### 应用场景：  
直观来看，当我们需要按照一定的顺序来处理数据，而该数据的数据量在不断地变化的时候，则需要队列来帮助解题。广度优先搜索（Breadth-First Search）是运用队列最多的地方之一


### 双端队列（Deque）
#### 应用场景  
双端队列最常用的地方就是实现一个长度动态变化的窗口或者连续区间，而动态窗口这种数据结构在很多题目里都有运用。

#### 例题分析  
```
LeetCode 第 239 题：给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字，滑动窗口每次只向右移动一位。返回滑动窗口最大值。

注意：你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。

示例：给定一个数组以及一个窗口的长度 k，现在移动这个窗口，要求打印出一个数组，数组里的每个元素是当前窗口当中最大的那个数。

输入：nums = [1, 3, -1, -3, 5, 3, 6, 7]，k = 3
输出：[3, 3, 5, 5, 6, 7]
```
解题思路
```
利用一个双端队列来保存当前窗口中最大那个数在数组里的下标，双端队列新的头就是当前窗口中最大的那个数。通过该下标，可以很快地知道新的窗口是否仍包含原来那个最大的数。如果不再包含，我们就把旧的数从双端队列的头删除。  
因为双端队列能让上面的这两种操作都能在 O(1) 的时间里完成，所以整个算法的复杂度能控制在 O(n)。
```



## 树
### 树的遍历
1 前序遍历  
应用场景：运用最多的场合包括在树里进行搜索以及创建一棵新的树。

2 中序遍历  
应用场景：最常见的是二叉搜素树，由于二叉搜索树的性质就是左孩子小于根节点，根节点小于右孩子，对二叉搜索树进行中序遍历的时候，被访问到的节点大小是按顺序进行的。  

3 后序遍历  
应用场景：在对某个节点进行分析的时候，需要来自左子树和右子树的信息。收集信息的操作是从树的底部不断地往上进行，好比你在修剪一棵树的叶子，修剪的方法是从外面不断地往根部将叶子一片片地修剪掉。


### 例题分析
```
LeetCode 第 230 题：给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。
```

解题思路
```
二叉搜索树的性质：
对于每个节点来说，该节点的值比左孩子大，比右孩子小
二叉搜索树中序遍历当中遇到的元素都是按照从小到大的顺序出现。

因此，我们只需要对这棵树进行中序遍历的操作，当访问到第 k 个元素的时候返回结果就好。
```

# 高级数据结构  

#