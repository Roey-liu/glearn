# 1 TCP header

<div align="center"> <img src="pic/TCPHeader.png"/> </div>

需要注意的是

* TCP的包是没有IP地址的，那是IP层上的事，但是有源端口和目标端口。  
* `一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。`但因为这里只是说TCP协议，所以，这里我只说四元组。

上图中的四个非常重要的东西：
* Sequence Number：是包的序号，用来解决网络包乱序（reordering）问题。
* Acknowledgement Number：就是ACK——用于确认收到，用来解决不丢包的问题。
* Window：也就是著名的滑动窗口（Sliding Window），用于解决流控的。
* TCP Flag ：也就是包的类型，主要是用于操控TCP的状态机的。


# 2 TCP stream / tcb  

用来干啥？  
```
用户态应用程序 和TCP的连接桥梁
```

里面主要有啥？
```
1 五元组：源端口号 源IP  目的端口号  目的IP 协议类型
2 status： 十一种状态
3 发送队列
4 接收队列
5 fd
```

应用程序的fd 和 tcb 有啥关系？ 

```
send(fd):  fd  去找 tcb
recv(fd):  tcb 去找 fd
```

# 3 TCP 的状态机

其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。

<div align="center"> <img src="pic/TCP状态机.png"/> </div>
（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）

### 为什么建链接要3次握手，断链接需要4次挥手？

* 对于3次握手：`主要是要初始化Sequence Number 的初始值`。
   + 通信的双方要互相通知对方自己的初始化的Sequence Number 也就上图中的 x 和 y。
   + 这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）
* 对于4次挥手：
   + 其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。





# 4 TCP滑动窗口

我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。

所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术

## 滑动窗口是如何保证顺序的？

1 首先假定主机B给主机A发送一个确认报文段【`rwnd=20 ack=31`】(表明主机B自己的接收窗口大小为20 期望收到的下一个序号为31(序号为30以及以前的数据收到了))   
主机A在收到确认报文后 就可以构造自己的发送窗口了，发送窗口的样子如图所示
<div align="center"> <img src="pic/滑动窗口01.png"/> </div>

2 现在假设主机A发送了序号【31-41】的数据，此时发送窗口的位置并没有改变,发送窗口内【31-41】的数据 已经发送但是还没收到确认，而序号为【42-50】的数据是允许发送但尚未发送的，考虑一下 我们如何描述发送窗口的状态？ 

<div align="center"> <img src="pic/滑动窗口02.png"/> </div>

3 我们再来看看主机B的接收窗口，假设主机A发送的【32-33】数据到达了主机B 由于他们序号落在了主机窗口内，所以主机B接收他们，将他们存入缓存，但是他们是未按序到达的数据（因为序号为31的数据还没有到达）请注意：**`主机B只能对按序收到的数据中的最高序号给出确认`** 因此主机B 因此主机B给出的确认报文段中的确认序号仍然是31（也就是希望收到序号为31的数据）
<div align="center"> <img src="pic/滑动窗口03.png"/> </div>

4 现在假定主机B收到了31的数据，并把数据交付给应用进程，之后，主机B就可以删除这些数据，并把接收窗口向前移动3个序号，给主机A发送确认报文段【`rwnd=20 ack=34`】
<div align="center"> <img src="pic/滑动窗口04.png"/> </div>

5 现在确认报文段【`rwnd=20 ack=34`】到达了主机A，主机A收到后就可以把发送窗口向前滑动3个序号 窗口尺寸仍为20，这样就有新序号落入滑动窗口中，而序号【31-33】数据就可以从窗口中删除了

<div align="center"> <img src="pic/滑动窗口05.png"/> </div>

6主机A继续发送数据 现在发送窗口内的发送序号已经都用完了（都发出去了）主机A在未收到主机B的确认下，不能在发送新的数据，发送窗口内的数据如果迟迟收不到来自主机B的确认，则会产生**超时重传**
<div align="center"> <img src="pic/滑动窗口06.png"/> </div>

## 什么时候给对端发送确认消息？


延迟ACK：每一次收到对方的包的时候，比如收到了一个37 这时候会开启一个定时器：叫做延迟定时器 超过200ms开始发送确认消息，检测之前的包有没有收到，如果200ms以内再有包进来，这时候会再开一个200ms的定时器


# 5 TCP拥塞控制
拥塞控制主要是四个算法：
* 1）慢启动；
* 2）拥塞避免；
* 3）拥塞发生；
* 4）快速恢复。


## 1 慢热启动算法 – Slow Start
慢启动的算法如下(cwnd全称Congestion Window)：

* 1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。
* 2）每当收到一个ACK，cwnd++; 呈线性上升
* 3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升
* 4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）
<div align="center"> <img src="pic/拥塞控制01.png"/> </div>



## 2 拥塞避免算法 – Congestion Avoidance

前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：

1）收到一个ACK时，cwnd = cwnd + 1/cwnd
2）当每过一个RTT时，cwnd = cwnd + 1

这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。