

# Http协议报文相关知识

## 基础概念

http报文可以分为请求报文和响应报文，格式大同小异
**主要分为三个部分**
   * 1）起始行；
     2）首部；
     3）主体。

**请求报文格式：**
```html
<method> <request-url> <version>
<headers>
 
<entity-body>
```
**响应报文格式：**
```html
<version> <status> <reason-phrase>
<headers>
 
<entity-body>
```
**这里稍微解释一下各个标签：**

```html
<method> 指请求方法，常用的主要是Get、 Post、Head 还有其他一些我们这里就不说了，有兴趣的可以自己查阅一下
<version> 指协议版本，现在通常都是Http/1.1了
<request-url> 请求地址
<status> 指响应状态码， 我们熟悉的200、404等等
<reason-phrase> 原因短语，200 OK 、404 Not Found 这种后面的描述就是原因短语，通常不必太关注。
```
## method

常用的有Get 和Post两种

**两者有什么区别，通常什么情况下使用**

1 两个方法之间在传输形式上有一些区别
* 通过Get方法发起请求时，会将请求参数拼接在request-url尾部，格式是url?param1=xxx¶m2=xxx&[…]。
   * 这样传输参数会使得参数都暴露在地址栏中。
   * 然http协议并没有对url长度做限制，但是一些浏览器和服务器可能会有限制，
   * 所以通过GET方法发起的请求参数不能够太长
* 而通过POST方法发起的请求是将参数放在请求体中的，所以不会有GET参数的这些问题。

2 另外一点差别就是方法本身的语义上的
* GET方法通常是指从服务器获取某个URL资源，其行为可以看作是一个读操作，对同一个URL进行多次GET并不会对服务器产生什么影响。
* POST方法通常是对某个URL进行添加、修改，例如一个表单提交，通常会往服务器插入一条记录

## 状态码

常见的状态码主要有
* 200 OK  请求成功，实体包含请求的资源
* 301 Moved Permanent 请求的URL被移除了，通常会在Location首部中包含新的URL用于重定向。
* 304 Not Modified    条件请求进行再验证，资源未改变。
* 404 Not Found       资源不存在
* 206 Partial Content 成功执行一个部分请求。这个在用于断点续传时会涉及到。

## header

在请求报文和响应报文中都可以携带一些信息，通过与其他部分配合，能够实现各种强大的功能。
这些信息位于起始行之下与请求实体之间，以键值对的形式，称之为首部。每条首部以回车换行符结尾，最后一个首部额外多一个换行，与实体分隔开
```html
Date  
Cache-Control  
Last-Modified  
Etag  
Expires  
If-Modified-Since   
If-None-Match  
If-Unmodified-Since  
If-Range  
If-Match
```

## 实体
请求发送的资源，或是响应返回的资源。




## 使用 Cookie 的状态管理

HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。
可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。
当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。
服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

**有两类cookie:**
* 1）会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；
* 2）而持久cookie则保存在硬盘中，计算机重启后仍然存在。

服务器在给客户端的响应字段首部加上Set-cookie或Set-cookie2, 值为名字=值的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过Cookie带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。

浏览器只会向产生这条cookie的站点发生cookie. Set-cookie字段的值会包含domain这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。path字段也是相似的功能。






## Http缓存相关的知识

当我们发起一个http请求后，服务器返回所请求的资源，这时我们可以将该资源的副本存储在本地，这样当再次对该url资源发起请求时，我们能快速的从本地存储设备中获取到该url资源，这就是所谓的缓存。

先摆出几个概念：
* 新鲜度检测；
* 再验证；
* 再验证命中。

### 新鲜度检测：
我们需要通过检测资源是否超过一定的时间，来判断缓存资源是否新鲜可用。

那么这个一定的时间怎么决定呢？其实是由服务器通过在响应报文中增加Cache-Control:max-age，或是Expire这两个首部来实现的
* Cache-Control是http1.1的协议规范，通常是接相对的时间，即多少秒以后，需要结合last-modified这个首部计算出绝对时间。
* 而Expire是http1.0的规范，后面接一个绝对时间。

### 再验证：

我们至少需要告诉服务器，我们已经缓存了一个什么样的资源了，然后服务器来判断这个缓存资源到底是不是与当前的资源一致。

那怎么告诉服务器我当前已经有一个备用的缓存资源了呢？我们可以采用一种称之为条件请求的方式实现再验证。

**Http定义了5个首部用于条件请求:**
* If-Modified-Since
* If-None-Match
* If-Unmodified-Since
* If-Range
* If-Match




## 代理
HTTP的代理服务器既是Web服务器，又是Web客户端。

<div align="center"> <img src="pic/http02.png"/> </div>
使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性



## 重定向与负载均衡
Web内容通常分散地分布在很多地方，这可以防止“单点故障”，这样，用户的请求会根据负载均衡的原则，被重定向到它应该去的地方。

### HTTP重定向：
服务器收到客户端请求后，向客户端返回一条带有状态码302重定向的报文，告诉他们应该去其他的地方试试。

web站点将重定向看成一种简单的负载均衡策略来使用，重定向服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。

当然，缺点也是显而易见的，由于客户端要发送两次请求，因此会增加耗时。

### DNS重定向：

DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的轮转；也可以是更高级的算法，如返回负载最轻的服务器的IP地址，称为负载均衡算法；如果考虑地理位置，返回给客户端最近位置的地址，称为邻接路由算法；还有一种是绕过出现故障的地址，称为故障屏蔽算法。

DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。


## HTTP连接

HTTP连接是HTTP报文传输的关键通道。

### 【并行连接】：
对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，速度会快起来。

如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。

**如果采用串行方式，那么连接时延会进行叠加：**
<div align="center"> <img src="pic/http03.png"/> </div>

**采用并行连接之后：**
<div align="center"> <img src="pic/http04.png"/> </div>

但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接

### 【持久连接】：

持久连接即HTTP的keep-alive机制

HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。
<div align="center"> <img src="pic/http05.png"/> </div>

### 【管道化连接】：

在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求按序放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。而且就算是服务端按序处理的，也不一定是按序返回给客户端，所以最好是在响应中附带一些可以标识请求的参数。




# 必须要掌握的Https知识

简单的说：Http + 加密 + 认证 + 完整性保护 = Https。

Http本身存在一些缺点： 
* Http协议使用明文传输，容易遭到窃听；
* Http对于通信双方都没有进行身份验证，通信的双方无法确认对方是否是伪装的客户端或者服务端；
* Http对于传输内容的完整性没有确认的办法，往往容易在传输过程中被劫持篡改。

## Https的加密原理
近代密码学中加密的方式主要有两类：
* 1）对称秘钥加密；
   * 对称秘钥加密是指加密与解密过程使用同一把秘钥。
   * 这种方式的优点是处理速度快，但是如何安全的从一方将秘钥传递到通信的另一方是一个问题。 
* 2）非对称秘钥加密。
   * 是指加密与解密使用两把不同的秘钥。 
   * 这两把秘钥，一把叫公开秘钥，可以随意对外公开。一把叫私有秘钥，只用于本身持有。
   * 得到公开秘钥的客户端可以使用公开秘钥对传输内容进行加密，而只有私有秘钥持有者本身可以对公开秘钥加密的内容进行解密。
   * 这种方式克服了秘钥交换的问题，但是相对于对称秘钥加密的方式，处理速度较慢。

SSL\TLS的加密方式则是结合了两种加密方式的优点。
* 首先采用非对称秘钥加密，将一个对称秘钥使用公开秘钥加密后传输到对方。对方使用私有秘钥解密，得到传输的对称秘钥。
* 之后双方再使用对称秘钥进行通信。这样即解决了对称秘钥加密的秘钥传输问题，又利用了对称秘钥的高效率来进行通信内容的加密与解密。

## Https的认证

SSL\TLS采用的混合加密的方式还是存在一个问题，即怎么样确保用于加密的公开秘钥确实是所期望的服务器所分发的呢？也许在收到公开秘钥时，这个公开秘钥已经被别人篡改了。因此，我们还需要对这个秘钥进行认证的能力，以确保我们通信的对方是我们所期望的对象。

目前的做法是使用由数字证书认证机构颁发的公开秘钥证书。服务器的运营人员可以向认证机构提出公开秘钥申请。认证机构在审核之后，会将公开秘钥与共钥证书绑定。服务器就可以将这个共钥证书下发给客户端，客户端在收到证书后，使用认证机构的公开秘钥进行验证。一旦验证成功，即可知道这个秘钥是可以信任的秘钥。

## Https的通信流程：

1）Client发起请求；
2）Server端响应请求，并在之后将证书发送至Client；
3）Client使用认证机构的共钥认证证书，并从证书中取出Server端共钥；
4）Client使用共钥加密一个随机秘钥，并传到Server；
5）Server使用私钥解密出随机秘钥；
6）通信双方使用随机秘钥最为对称秘钥进行加密解密。


# HTTP协议的历史演变和设计思路

## HTTP/0.9

最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET：

协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式：

服务器发送完毕，就关闭TCP连接。

## HTTP/1.0

首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。

其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段

再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。

其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。

## HTTP/1.1

### 持久连接
1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。
### 管道机制
1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率

### 其他功能

1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。

### 缺点
* 但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"

为了避免这个问题，只有两种方法：
 * 一是减少请求数，二是同时多开持久连接。

## HTTP/2

### 二进制协议
HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

### 多工

HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

### 数据流

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

### 头信息压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

### 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。