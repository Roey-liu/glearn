## DNS 源起

直接使用IP地址是一个愚蠢的方案。于是人们想出了一个替代的方法，即为每一台计算机起一个名字，然后建立计算机名字到地址的一个映射关系。

### hosts映射

早期，名字到地址的转换过程十分简单。每台计算机保存一个hosts文件，里面列出所有计算机名字和对应的IP地址，然后定期从一个维护此文件的站点更新里面的记录。当我们访问某个计算机名字时，先在hosts文件找到对应的IP，然后就可以建立连接

<div align="center"> <img src="pic/DNS01.png"/> </div>

缺点：
* 1）hosts文件变得非常大；
* 2）主机名字会冲突；
* 3）集中的维护站点会不堪重负（需要给几百万机器提供hosts文件，想想就可怕

### 域名系统

DNS 通过下面三种手段解决了上面的问题：
* 1）用户计算机上并没有存储所有的名字到IP的映射，这样避免了hosts文件过于庞大（现在各操作系统中hosts文件默认都是空的）；
* 2）规定了域名的命名规则，保证主机名字不会重复；
* 3）DNS服务器不再是单一的一台机器，而是一个层次的、合理组织的服务器集群
<div align="center"> <img src="pic/DNS02.png"/> </div>

## DNS 协议

### 域名空间

首先我们需要制定一套命名规则，防止域名出现重复 

DNS关于域名的规则和我们生活中的快递系统类似，使用层次的地址结构。

对于Internet来说，域名层次结构的顶级（相当于国际快递地址中的国家部分）由ICANN（互联网名称与数字地址分配机构）负责管理。目前，已经有超过250个顶级域名，每个顶级域名可以进一步划为一些子域（二级域名），这些子域可被再次划分（三级域名），依此类推

<div align="center"> <img src="pic/DNS03.png"/> </div>

### 域名资源记录

DNS设计之初是用来建立域名到IP地址的映射，理论上对于每一个域名我们只需要在域名服务器上保存一条记录即可

*这里的记录一般叫作域名资源记录，它是一个五元组，可以用以下格式表示：*

* Domain_name  Time_to_live  Class  Type  Value
   * 1）Domain_name: 指出这条记录适用于哪个域名；
   * 2）Time_to_live: 用来表明记录的生存周期，也就是说最多可以缓存该记录多长时间；
   * 3）Class: 一般总是IN；
   * 4）Type: 记录的类型；
   * 5）Value: 记录的值，如果是A记录，则value是一个IPv4地址。

### 域名服务器

如何合理地将所有的域名资源记录存储到不同的域名服务器上。

前面说过域名的名字空间可以组织为一棵树，这里我们可以进一步将其划分为不重叠的区域（DNS zone）。

<div align="center"> <img src="pic/DNS04.png"/> </div>

然后将每个区域与多个域名服务器（其中一个是master，其他slave服务器则用来提供数据备份、加快解析速度、保证服务可用性）关联起来，称这些域名服务器为该区域的权威域名服务器(Authoritative Name Servers )。


下面以一个简化的域名空间为例子，说明域名资源记录是如何保存在域名服务器中的。

<div align="center"> <img src="pic/DNS05.png"/> </div>

图中域名空间划分为A, B, C, D, E, F, G七个DNS区域，每个DNS区域都有多个权威域名服务器，这些域名服务器里面保存了许多域名解析记录。

图你可能会发现区域A、B并没有父区域，他们之间并没有一条路径连在一起 ,将导致一个很麻烦的问题，那就是区域A的权威域名服务器可能根本不知道区域B的存在。

* 解决办法就是引入根域名服务器，它保存了所有顶级区域的权威域名服务器记录。现在通过根域名服务器，我们可以找到所有的顶级区域的权威域名服务器

**下图为全球根域名服务器的分布图：**
<div align="center"> <img src="pic/DNS06.png"/> </div>

### 域名解析

域名解析的过程最早要追溯到建立网络连接。因为每当连接上网络之后，计算机会自动获得一个默认的DNS服务器，当然你也可以用自己信任的DNS服务器，比如8.8.8.8 我们把这个域名服务器也叫作本地域名服务器。

接下来当我们需要知道一个域名对应的资源记录时，会向本地域名服务器发起请求，如果该域名恰好在本地域名服务器所辖属的域名区域（DNS zone）内，那么可以直接返回记录。

如果在本地域名服务器没有发现该域名的资源记录，就需要在整个域名空间搜索该域名。 本地域名服务器首先要从根域名服务器开始往下搜索

这里有一个问题就是：本地域名服务器如何找到根域名服务器在哪里呢？ 
* 其实域名服务器启动的时候，就会加载一个配置文件，里面保存了根域名服务器的NS记录
* （要知道根域名服务器地址一般非常稳定，不会轻易改变，并且数量很少，所以这个配置文件会很小）。
* 找到根域名服务器之后，就可以一级一级地往下查找啦。

这和我们邮寄快递实在是如出一辙啊，假设你从美国邮东西到广州市番禺区，首先快递送到中国（不过这里没有一个类似根域名服务器的中转站而已），然后往下到广东省，接下来是广州市，再往下是番禺了。

## 缓存机制

1）80%的时间我们都在看那些20%的网站，这就是大名鼎鼎的 80/20 Rule；
2）我们会在一个网站的不同网页之间跳转，也就是不断地访问同一个域名，类似程序访问的局部性原理。


* 我们在域名资源记录里面添加一个 Time_to_live 字段，表明这条记录最多可以缓存多久。
* 对于那些“稳如泰山”的域名，给一个比较大的值，而那些“朝三暮四”的域名，则可以给定一个小的值。


## 域名注册、绑定

大多数时候我们希望去注册一个顶级域名（比如google.com），那些二级域名毕竟不够好记（比如github托管博客的域名：username.github.io）

要想去注册域名，首先得找到域名注册商，国内的比较著名的有万网等（PS：万网已被阿里收购了），国外的有godaddy等。

现实中，大部分人可能会拥有个人博客 假设你的博客已经可以通过 username.github.io 访问，接下来只需要用 CNAME 告诉Github你的博客绑定了哪个域名（比如说是selfboot.cn），然后在域名解析商那里添加解析记录即可。


## DNS目前存在的缺陷

### 域名抢注
域名可以被倒卖。

### DNS 劫持

我们知道一个域名服务器对其区域内的用户解析请求负责，但是并没有一个机制去监督它有没有真地负责。于是有些流氓的域名服务器故意更改一些域名的解析结果，将用户引向一个错误的目标地址。这就叫作 DNS 劫持

<div align="center"> <img src="pic/DNS07.png"/> </div>



国内运营商LocalDNS造成的这些问题，可以归为下以下3种原因：

#### 1-域名缓存

<div align="center"> <img src="pic/DNS09.png"/> </div>

为何LocalDNS要把域名解析结果进行缓存呢？原因有以下几个：
* 1）保证用户访问流量在本网内消化：
* 2）推送广告：

**域名缓存会导致用户产生以下的访问异常**
* A、仅对80端口的http服务做了缓存，如果域名是通过https协议或其它端口提供服务的，用户访问就会出现失败。比如支付服务、游戏通过指定端口连接connect server服务等；
* B、缓存服务器的运维水平参差不齐，时有出现缓存服务器故障导致用户访问异常的问题。

#### 2-解析转发

除了域名缓存以外，运营商的LocalDNS还存在解析转发的现象。
解析转发是指运营商自身不进行域名递归解析，而是把域名解析请求转发到其它运营商的递归DNS上的行为。

* 部分小运营商为了节省资源，就直接将解析请求转发到了其它运营的递归LocalDNS上去了：

**这样的直接后果就是腾讯权威DNS收到的域名解析请求的来源IP就成了其它运营商的IP，最终导致用户流量被导向了错误的IDC，用户访问变慢。**

#### 3-LocalDNS递归出口NAT

指的是运营商的LocalDNS按照标准的DNS协议进行递归，但是因为在网络上存在多出口且配置了目标路由NAT，结果导致LocalDNS最终进行递归解析的时候的出口IP就有概率不为本网的IP地址。
**这样的直接后果就是GSLB DNS收到的域名解析请求的来源IP还是成了其它运营商的IP，最终导致用户流量被导向了错误的IDC，用户访问变慢。**

####  当前主流的解决方案：HttpDNS


**HTTPDNS 利用 HTTP 协议与 DNS 服务器交互，代替了传统的基于 UDP 协议的 DNS 交互，绕开了运营商的 Local DNS，有效防止了域名劫持，提高域名解析效率**

<div align="center"> <img src="pic/DNS10.png"/> </div>

HttpDns 主要解决的问题

* Local DNS 劫持：由于 HttpDns 是通过 IP 直接请求 HTTP 获取服务器 A 记录地址，不存在向本地运营商询问 domain 解析过程，所以从根本避免了劫持问题。

* 平均访问延迟下降：由于是 IP 直接访问省掉了一次 domain 解析过程，通过智能算法排序后找到最快节点进行访问。

* 用户连接失败率下降：通过算法降低以往失败率过高的服务器排序，通过时间近期访问过的数据提高服务器排序，通过历史访问成功记录提高服务器排序。


### DNS 欺骗

DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的 DNS 应答 

在一台主机发出 DNS 请求后，它就开始等待应答，如果此时有一个看起来正确（拥有和DNS请求一样的序列号）的应答包，它就会信以为真，并且丢弃稍晚一点到达的应答。

<div align="center"> <img src="pic/DNS08.png"/> </div>

**实施 DNS 欺骗的关键在于伪造一个有特定序列号的应答包，并且让其抢先一步到达发起请求的主机**

## DNS杂症
