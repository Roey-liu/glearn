
## 搞这玩意有啥好处

 1 TCP的细节  
 2 服务器并发数量的极限  
 3 网卡数据的理解


## 单台服务器并发数量的极限在哪？ 

我们应该考虑以下五元组  

-------**CPU  内存  网卡  带宽   内核**

结论是如今最大的瓶颈在于内核 于是有人提出把协议栈搬到用户态的解决方案


##  如何把协议栈做到用户态里面？ 

将网卡映射到内存中： netmap/dpdk  

站在CPU的角度  mmap  把网卡内部（网卡上存储数据）空间 之间映射到内存中

这样 就使得我们操作网卡和操作内存是一样的 这个就是把协议栈做到用户态的基础


##  如何在netmap基础上面实现一个小的UDP协议栈？

UDP数据帧如下
![](img/udp数据帧.png)



以太网协议头

![](img/以太网协议头.png)

```
struct ethhdr {
	unsigned char h_dest[ETH_ALEN];
	unsigned char h_source[ETH_ALEN];
	unsigned short h_proto;
} __attribute__ ((packed));
```

IP协议

![](img/IP头.png)
```
标识：也就是说的每一个的ID号 唯一地标识主机发送的每一个数据报，其初始值是随机的，每发送一个数据报其值就加1。
 
标志: 位1保留，位2表禁止分片(DF)，若设置了此位，IP模块将不对数据报进行分片，在此情况下若IP数据报超过MTU，IP模块将丢弃数据报并返回一个ICMP差错报文；位3标识更多分片(MF)，除了数据报的最后一个分片，其他分片都要把它设置为1
  
位偏移：分片相对原始IP数据报数据部分的偏移。
  
生存时间:：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置，常设置为64。数据报在转发过程中每经过一个路由该值就被路由器减1.当TTL值为0时，路由器就将该数据包丢弃，并向源端发送一个ICMP差错报文。

```
```
struct iphdr {
	unsigned char version:4;
    unsigned char ihl:4;
	unsigned char tos;
	unsigned short tot_len;
	unsigned short id;
	unsigned short flag_off;
	unsigned char ttl;
	unsigned char protocol;
	unsigned short check;
	unsigned int saddr;
	unsigned int daddr;
} __attribute__ ((packed));
```

### 为啥每一层都有一个效验？
因为之前的网络丢失情况还是很严重的 所以在每一层都在加校验 更方便去查找那一层出现了问题


### 当我们发送一个udp数据包 这个包里面都有啥玩意？








1  fd  连接数量的限制

2  协议栈做成应用程序
    避免了系统调用的copy



如何把协议栈做到应用程序里面？ 

  mmap核心的东西（DMA）





网络协议栈知识

发送一个UDP的数据包

sendto()  recvfrom();

udphdr(8)

iphdr (20)

ethr_headrr (14)





















