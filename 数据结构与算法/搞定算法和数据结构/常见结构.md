# 基础数据结构

## 数组、字符串（Array & String）
### 数组的优缺点  
数组的优点在于：  
* 构建非常简单  
* 能在O(1)的时间里根据数组的下标（index）查询某个元素  

数组的缺点在于：

* 构建时必须分配一段连续的空间
* 查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）
* 删除和添加某个元素时，同样需要耗费 O(n) 的时间

### 例题分析
```
LeetCode 第 242 题：给定两个字符串 s 和 t，编写一个函数来判断 t 是否是 s 的字母异位词。

说明：你可以假设字符串只包含小写字母。

示例 1
输入: s = "anagram", t = "nagaram"
输出: true

示例 2
输入: s = "rat", t = "car"
输出: false
```
解题思路
```
可以只利用一个长度为 26 的字符数组，将出现在字符串 s 里的字符个数加 1，而出现在字符串 t 里的字符个数减 1，最后判断每个小写字母的个数是否都为 0。
```
代码实现
```
bool isAnagram(string s, string t) {	
	if (s.size() != t.size()) {
		return false;
	}

	vector<int>alph(26,0);

	for (size_t i = 0; i < s.size(); i++){
		alph[s[i] - 'a']++;
		alph[t[i] - 'a']--;	
	}


	for (size_t i = 0; i < 26; i++)
	{
		if (alph[i] != 0) {
			return false;
		}
	}

	return true;
}
```
### 链表（LinkedList）
#### 链表的优缺点
链表的优点如下：
* 链表能灵活地分配内存空间；
* 能在 O(1) 时间内删除或者添加元素

链表的缺点是：
* 不像数组能通过下标迅速读取元素，每次都要从链表头开始一个一个读取；
* 查询第 k 个元素需要 O(k) 时间。

### 应用场景：  
如果要解决的问题里面需要很多快速查询，链表可能并不适合；如果遇到的问题中，数据的元素个数不确定，而且需要经常进行数据的添加和删除，那么链表会比较合适。而如果数据元素大小确定，删除插入的操作并不多，那么数组可能更适合。

### 经典解法

1-利用快慢指针（有时候需要用到三个指针）  

典型题目例如：链表的翻转，寻找倒数第 k 个元素，寻找链表中间位置的元素，判断链表是否有环等等

2-构建一个虚假的链表头  
一般用在要返回新的链表的题目中  
比如，给定两个排好序的链表，要求将它们整合在一起并排好序。  
又比如，将一个链表中的奇数和偶数按照原定的顺序分开后重新组合成一个新的链表，链表的头一半是奇数，后一半是偶数。

### 例题分析
```
LeetCode 第 25 题：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

说明：
你的算法只能使用常数的额外空间。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例：
给定这个链表：1->2->3->4->5
当 k=2 时，应当返回：2->1->4->3->5
当 k=3 时，应当返回：3->2->1->4->5
```
解题思路
```
借助三个指针：prev、curr、next

将 curr 指向的下一节点保存到 next 指针；
curr 指向 prev，一起前进一步；
重复之前步骤，直到 k 个元素翻转完毕；

当完成了局部的翻转后，prev 就是最终的新的链表头，curr 指向了下一个要被处理的局部，而原来的头指针 head 成为了链表的尾巴。
```

## 栈 队列 双端队列
### 栈
#### 应用场景：
 在解决某个问题的时候，只要求关心最近一次的操作，并且在操作完成了之后，需要向前查找到更前一次的操作。  

#### 例题分析一
```
LeetCode 第 20 题：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意：空字符串可被认为是有效字符串。

示例 1
输入: "()"
输出: true

示例 2
输入: "(]"
输出: false
```
解题思路
```
利用一个栈，不断地往里压左括号，一旦遇上了一个右括号，我们就把栈顶的左括号弹出来，表示这是一个合法的组合，以此类推，直到最后判断栈里还有没有左括号剩余。
```
#### 例题分析二
```
LeetCode 第 739 题：根据每日气温列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

提示：气温列表 temperatures 长度的范围是 [1, 30000]。

示例：给定一个数组 T 代表了未来几天里每天的温度值，要求返回一个新的数组 D，D 中的每个元素表示需要经过多少天才能等来温度的升高。
给定 T：[23, 25, 21, 19, 22, 26, 23]
返回 D: [1, 4, 2, 1, 1, 0, 0]
```
解题思路
```
可以运用一个堆栈 stack 来快速地知道需要经过多少天就能等到温度升高。从头到尾扫描一遍给定的数组 T，如果当天的温度比堆栈 stack 顶端所记录的那天温度还要高，那么就能得到结果。
```




## 树




# 高级数据结构