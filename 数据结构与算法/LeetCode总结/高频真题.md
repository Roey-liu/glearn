# 中等难度

## 线性法及优化线性法

<div align="center"> <img src="pic/LC03.png"/> </div>

解题思路一：暴力法

找出所有的子串，然后一个一个地去判断每个子串里是否包含有重复的字符


假设字符串的长度为 n，那么有 n×(n + 1) / 2 个非空子串  

长度为 1 的子序列有 n 个，即 Cn1，长度为 2 的子序列个数为 Cn2，以此类推，长度为 k 的子序列有 Cnk，那么所有子序列的个数（包括空序列）是 Cn0 + Cn1 + Cn2 + … Cnn = 2^n

解题思路二：线性法
```
可以定义两个指针 i 和 j。

i 是慢指针，j 是快指针，当 j 遇到了一个重复出现的字符时，从慢指针开始一个一个地将 i 指针指向的字符从集合里删除，然后判断一下是否可以把新字符加入到集合里而不会产生重复。

通过这样不断尝试，每当新的字符加入到集合里的时候，统计一下当前集合里的元素个数，最后记录下最长的那个。
```





## 切分法

<div align="center"> <img src="pic/LC04.png"/> </div>

解题思路一：暴力法  

因为两个数组都是排好序的，可以利用归并排序将它们合并成一个长度为 m+n 的有序数组，合并的时间复杂度是 m+n，然后从中选取中位数，整体的时间复杂度就是 O(m+n)。

这是比较直观的解法，但是比题目要求的 O(log(m+n)) 慢了许多，并不适合。

解题思路二：切分法

假设 m+n = L，若 L 为奇数，即两个数组的元素总个数为奇数，那么它们的中位数就是第 int(L / 2) + 1 小的数。例如，数组 { 1, 2, 3 } 的中位数是 2，2 就是第二小的数 2 = int(3/2) + 1。  

如果 L 是偶数，那么中位数就是第 int(L/2) 小与第 int(L/2)+1 小的数的和的平均值。例如，数组 {1, 2, 3, 4} 的中位数是 (2 + 3) / 2 = 2.5，其中，2 = int(4/2)，3 = int(4/2) + 1。   

因此这个问题就转变为在两个有序数组中寻找第 k 小的数 f(k)，当 L 是奇数的时候，另 k = L/2，结果为 f(k + 1)；而当 L 是偶数的时候，结果为 f(k) + f(k + 1) / 2。



如何从两个排好序的数组里找出第 k 小的数？

## 快速选择算法



## 最小堆法



## 分治法

## 合并区间和无重叠区间

## 火星字典

## 基本计算器


# 比较难

## 正则表达式匹配

## 柱状图中的最大矩形

## 实现 strStr() 函数

## 回文对

## 至多包含 K 个不同字符的最长子串
 

  
## 接雨水 II

